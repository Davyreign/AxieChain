"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseWrapper = void 0;
const add_contract_wait_1 = require("../helpers/add-contract-wait");
class BaseWrapper {
    overwriteEthersContract(contract) {
        const wrapper = this;
        const contractPrototype = Object.getPrototypeOf(contract);
        const wrappedContract = Object.assign(Object.create(contractPrototype), contract);
        const functionNames = Object.keys(contract.functions);
        functionNames.forEach((functionName) => {
            if (functionName.indexOf("(") == -1) {
                const isCall = contract.interface.getFunction(functionName).constant;
                wrappedContract[functionName] = async function (...args) {
                    const tx = await contract.populateTransaction[functionName](...args);
                    // Appending redstone data to the transaction calldata
                    const dataToAppend = await wrapper.getBytesDataForAppending({
                        functionName,
                        contract,
                        transaction: tx,
                    });
                    tx.data = tx.data + dataToAppend;
                    if (isCall) {
                        const result = await contract.signer.call(tx);
                        const decoded = contract.interface.decodeFunctionResult(functionName, result);
                        return decoded.length == 1 ? decoded[0] : decoded;
                    }
                    else {
                        const sentTx = await contract.signer.sendTransaction(tx);
                        // Tweak the tx.wait so the receipt has extra properties
                        (0, add_contract_wait_1.addContractWait)(contract, sentTx);
                        return sentTx;
                    }
                };
            }
        });
        return wrappedContract;
    }
}
exports.BaseWrapper = BaseWrapper;
//# sourceMappingURL=BaseWrapper.js.map