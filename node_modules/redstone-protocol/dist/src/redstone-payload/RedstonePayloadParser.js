"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedstonePayloadParser = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const redstone_constants_1 = require("../common/redstone-constants");
const utils_2 = require("../common/utils");
const DataPackage_1 = require("../data-package/DataPackage");
const SignedDataPackage_1 = require("../data-package/SignedDataPackage");
const NumericDataPoint_1 = require("../data-point/NumericDataPoint");
class RedstonePayloadParser {
    // Last bytes of bytesData must contain valid redstone payload
    constructor(bytesData) {
        this.bytesData = bytesData;
    }
    parse() {
        this.assertValidRedstoneMarker();
        let unsignedMetadata = this.extractUnsignedMetadata();
        let negativeOffset = unsignedMetadata.length +
            redstone_constants_1.UNSGINED_METADATA_BYTE_SIZE_BS +
            redstone_constants_1.REDSTONE_MARKER_BS;
        const numberOfDataPackages = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.DATA_PACKAGES_COUNT_BS,
        });
        negativeOffset += redstone_constants_1.DATA_PACKAGES_COUNT_BS;
        // Extracting all data packages
        const signedDataPackages = [];
        for (let i = 0; i < numberOfDataPackages; i++) {
            const signedDataPackage = this.extractSignedDataPackage(negativeOffset);
            signedDataPackages.push(signedDataPackage);
            negativeOffset += signedDataPackage.toBytes().length;
        }
        // Preparing remainder prefix bytes
        const remainderPrefix = this.slice({
            negativeOffset,
            length: this.bytesData.length - negativeOffset,
        });
        return {
            signedDataPackages: signedDataPackages.reverse(),
            unsignedMetadata,
            remainderPrefix,
        };
    }
    extractUnsignedMetadata() {
        const unsignedMetadataSize = this.extractNumber({
            negativeOffset: redstone_constants_1.REDSTONE_MARKER_BS,
            length: redstone_constants_1.UNSGINED_METADATA_BYTE_SIZE_BS,
        });
        return this.slice({
            negativeOffset: redstone_constants_1.REDSTONE_MARKER_BS + redstone_constants_1.UNSGINED_METADATA_BYTE_SIZE_BS,
            length: unsignedMetadataSize,
        });
    }
    assertValidRedstoneMarker() {
        const redstoneMarker = this.slice({
            negativeOffset: 0,
            length: redstone_constants_1.REDSTONE_MARKER_BS,
        });
        const redstoneMarkerHex = (0, utils_1.hexlify)(redstoneMarker);
        if (redstoneMarkerHex !== redstone_constants_1.REDSTONE_MARKER_HEX) {
            throw new Error(`Received invalid redstone marker: ${redstoneMarkerHex}`);
        }
    }
    extractSignedDataPackage(initialNegativeOffset) {
        // Extracting signature
        let negativeOffset = initialNegativeOffset;
        const signature = this.slice({
            negativeOffset,
            length: redstone_constants_1.SIGNATURE_BS,
        });
        // Extracting number of data points
        negativeOffset += redstone_constants_1.SIGNATURE_BS;
        const dataPointsCount = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.DATA_POINTS_COUNT_BS,
        });
        // Extracting data points value byte size
        negativeOffset += redstone_constants_1.DATA_POINTS_COUNT_BS;
        const dataPointsValueSize = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.DATA_POINT_VALUE_BYTE_SIZE_BS,
        });
        // Extracting timestamp
        negativeOffset += redstone_constants_1.DATA_POINT_VALUE_BYTE_SIZE_BS;
        const timestamp = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.TIMESTAMP_BS,
        });
        // Extracting all data points
        negativeOffset += redstone_constants_1.TIMESTAMP_BS;
        const dataPoints = [];
        for (let i = 0; i < dataPointsCount; i++) {
            // Extracting data point value
            const dataPointValue = this.slice({
                negativeOffset,
                length: dataPointsValueSize,
            });
            // Extracting data feed id for data point
            negativeOffset += dataPointsValueSize;
            const dataFeedId = this.slice({
                negativeOffset,
                length: redstone_constants_1.DATA_FEED_ID_BS,
            });
            // Shifting negative offset
            negativeOffset += redstone_constants_1.DATA_FEED_ID_BS;
            // Building a data point
            const dataPoint = this.createDataPoint(dataFeedId, dataPointValue);
            // Collecting data point
            // Using `unshift` instead of `push` because we read from the end
            dataPoints.unshift(dataPoint);
        }
        return new SignedDataPackage_1.SignedDataPackage(new DataPackage_1.DataPackage(dataPoints, timestamp), (0, utils_1.hexlify)(signature));
    }
    // This is a bit hacky, but should be enough for us at this point
    createDataPoint(dataFeedId, dataPointValue) {
        return new NumericDataPoint_1.NumericDataPoint({
            dataFeedId: (0, utils_1.toUtf8String)(dataFeedId).replaceAll("\x00", ""),
            value: ethers_1.BigNumber.from(dataPointValue).toNumber() / 10 ** 8,
        });
    }
    extractNumber(sliceConfig) {
        const bytesArr = this.slice(sliceConfig);
        return (0, utils_2.convertBytesToNumber)(bytesArr);
    }
    slice(sliceConfig) {
        const { negativeOffset, length } = sliceConfig;
        const end = this.bytesData.length - negativeOffset;
        const start = end - length;
        return this.bytesData.slice(start, end);
    }
}
exports.RedstonePayloadParser = RedstonePayloadParser;
//# sourceMappingURL=RedstonePayloadParser.js.map